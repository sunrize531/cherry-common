from bisect import insort_left
from collections import MutableMapping, OrderedDict
import random
import struct
import hashlib
from threading import Lock
import os
from cherrycommon.timeutils import seconds, milliseconds


_inc_lock = Lock()
_inc = 0
_pid = int(os.getpid()) % 0xffff


def random_id(length=18):
    """Generate id, based on timestamp, assumed to be unique for this process.
    """
    global _inc
    ts = milliseconds()
    with _inc_lock:
        source = '{}{}{}'.format(ts, _pid, _inc)
        _inc += 1
    return hash_string(source, length)


def unique_id():
    """Generate random id, based on timestamp, assumed to be unique for this process.
    Note, that strings, generated by this function will be sorted, i.e. each next string will be greater than previous.
    Do not use this function for very quick generation of pack of ids cause of possible collisions.
    """
    global _inc
    ts = milliseconds()
    s = ts / 1000
    ds = ts / 100 - s * 10
    with _inc_lock:
        source = '{}{}{}{}'.format(
            struct.pack('>I', s),
            struct.pack('>B', ds),
            struct.pack('>H', _pid),
            struct.pack('>H', _inc % 0xffff)
        )
        _inc += 1
    return source.encode('hex')


def hash_string(source, length=18):
    """Generate truncated to length hexdigest for provided source string.

    :param source: string to computes hash from.
    :type source: basestring
    :param length: truncate hash to the specified length.
    :type length: int
    :rtype: str
    """
    return hashlib.sha256(source).hexdigest()[0:length]


class Median(object):
    def __init__(self, *args):
        self.values = sorted(args)

    def __add__(self, other):
        insort_left(self.values, float(other))
        return self

    def clear(self):
        self.values = []

    @property
    def min(self):
        try:
            return self.values[0]
        except IndexError:
            return 0

    @property
    def max(self):
        try:
            return self.values[-1]
        except IndexError:
            return 0

    @property
    def len(self):
        return len(self.values)

    @property
    def avg(self):
        return self.sum / max(self.len, 1)

    @property
    def med(self):
        index = int(self.len / 2)
        try:
            return self.values[index]
        except IndexError:
            return 0

    @property
    def sum(self):
        return sum(self.values)

    def __repr__(self):
        return '<Median: (min: {:.1f}, max: {:.1f}, med: {:.1f}, avg: {:.2f})>'.format(
            self.min, self.max, self.med, self.avg)

    def __str__(self):
        return self.__repr__()


class WeightedItem(object):
    __slots__ = 'name', 'weight', 'toughness', 'hunger'

    def __init__(self, name, weight=1):
        self.name = name
        self.weight = weight
        self.toughness = 0
        self.hunger = 0

    def __repr__(self):
        return '(weight: {}, toughness: {}, hunger: {})'.format(self.weight, self.toughness, self.hunger)

    def __str__(self):
        return self.__repr__()


class Weights(MutableMapping):
    def __init__(self, **kwargs):
        self._items = {}
        self._updated = True
        self._total = 0
        self._len = 0
        self._first = None
        self._last = None
        self.update(kwargs)

    def __getitem__(self, item):
        return self._items[item].weight

    def __setitem__(self, key, value):
        if value >= 0:
            try:
                self._items[key].weight = value
            except KeyError:
                self._items[key] = WeightedItem(key, value)
        else:
            raise ValueError('Value should be positive or zero.')
        self._updated = True

    def __delitem__(self, key):
        del self._items[key]
        self._updated = True

    def __len__(self):
        return len(self._items)

    def __contains__(self, item):
        return self._items.__contains__(item)

    def keys(self):
        return self._items.keys()

    def __iter__(self):
        return iter(self.keys())

    def _refresh_heights(self):
        l = self._len = len(self._items)
        if not l:
            raise IndexError('Cannot choose from nothing.')

        items = sorted(self._items.values(), key=lambda item: item.weight)
        t = 0
        for item in items:
            t += item.weight
            item.toughness = t
        total = self._total = t

        t = 0
        c = l - 1
        for item in items:
            t += float(total - item.weight) / c
            item.hunger = t

        self._items = OrderedDict()
        for item in items:
            self._items[item.name] = item
        self._first = items[0]

    def roll(self):
        return random.random() * self._total

    def choice(self, thin=False):
        if self._updated:
            self._refresh_heights()
            self._updated = False

        if self._len < 2:
            if self._first:
                return self._first.name
            else:
                raise IndexError('Nothing to choose')

        r = self.roll()
        if not thin:
            for item in self._items.itervalues():
                if r < item.toughness:
                    return item.name
        else:
            for item in self._items.itervalues():
                if r < item.hunger:
                    return item.name

        raise IndexError('Nothing to choose')

    def __repr__(self):
        return '<Weights: {}>'.format(self._items)

    def __str__(self):
        return self.__repr__()
